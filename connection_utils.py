def clock_neuron_connections(clock_df, direction, min_weight):
    """
    Gets input/output connections of clock neurons as well as connections between clock neurons.

    Parameters:
    clock_df = the dataframe generated by getClock()
    direction = (string) specified connection direction to run:
        'in' for inputs to clock neurons from anything else, 
        'out' for outputs from clock neurons to anything else,
        'intra_clock' for connections between clock neurons.
    min_weight = minimum weight in one direction required between two neurons to be included
    """
    from neuprint import fetch_adjacencies
    
    if direction == 'out':
        # get outputs from clock neurons to anything else
        neuron_df, conn_df = fetch_adjacencies(clock_df['bodyId'], None, min_total_weight=min_weight)
    if direction == 'in':
        # get inputs to clock neurons from anything else
        neuron_df, conn_df = fetch_adjacencies(None, clock_df['bodyId'], min_total_weight=min_weight)
    if direction == 'intra_clock':
        #getting the connections between clock neurons
        neuron_df_clock, conn_df_clock = fetch_adjacencies(clock_df['bodyId'], clock_df['bodyId'], min_total_weight=min_weight)
    
    # consolidate since we don't care about separating connections between 2 neurons that happen in different ROIs.
    conns_df = conn_df.groupby(['bodyId_pre', 'bodyId_post'], as_index=False)['weight'].sum()
    return conns_df

def synapse_count(conns_df, direction, intra_clock=False):
    """
    Gets total input or output synapse count for clock neurons.

    Parameters:
    conns_df = the table of connections generated by clock_neuron_connections()
    direction = (string) specified connection direction to run:
        'in' for inputs to clock neurons from anything else, 
        'out' for outputs from clock neurons to anything else.
    intra_clock = default False. Set to True for synapse count between clock neurons.
        If set to True, adds the string 'clock' to the output column name for differentiating purposes.
    """
    clock = ''

    if direction == 'out':
        column_to_group_on = 'bodyId_pre'
    if direction == 'in':
        column_to_group_on = 'bodyId_post'
    if intra_clock:
        clock = 'clock_'

    syns_df = conns_df.groupby([column_to_group_on], as_index=False)['weight'].sum()
    syns_df = syns_df.rename(columns={"weight": f"num_{clock}{direction}_syns",[column_to_group_on]:"bodyId"})
    
    return syns_df

def synaptic_partner_numbers(conns_df, direction, intra_clock=False):
    """
    Get number of pre or postsynaptic partners of the clock neurons using value_counts of the post or presynaptic bodyIds
    
    Parameters:
    conns_df = the table of connections generated by clock_neuron_connections()
    direction = (string) specified connection direction to run:
        'in' for inputs to clock neurons from anything else, 
        'out' for outputs from clock neurons to anything else.
    intra_clock = default False. Set to True for synapse count between clock neurons.
        If set to True, adds the string 'clock' to the output column name for differentiating purposes.
    """ 
    clock = ''
    if direction == 'out':
        column_to_group_on = 'bodyId_pre'
        pre_or_post = 'post'
    if direction == 'in':
        column_to_group_on = 'bodyId_post'
        pre_or_post = 'pre'
    if intra_clock:
        clock = 'clock_'

    partners_df = clock_conns_df[column_to_group_on].value_counts().to_frame().reset_index()
    partners_df = partners_df.rename(columns={"index":"bodyId", column_to_group_on:f"num_{clock}{pre_or_post}syn_partners"})

    return partners_df